# API Contracts
## Ya OK - Comprehensive API Documentation

**Document ID:** YA-OK-API-001  
**Version:** 1.0  
**Date:** 2026-02-06  
**Status:** Draft  
**Classification:** INTERNAL

---

## Document Control

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-02-06 | Backend Team | Initial version - Complete API contracts |

### Approvals

| Role | Name | Signature | Date |
|------|------|-----------|------|
| Backend Lead | [TBD] | | |
| Technical Architect | [TBD] | | |
| Product Owner | [TBD] | | |

### Related Documents

- **YA-OK-ARCH-001**: C4 Architecture Diagrams
- **YA-OK-SRS-001**: Software Requirements Specification
- **YA-OK-SEC-002**: Security Requirements Specification
- **YA-OK-SEQ-001**: Sequence Diagrams

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [FFI Interface (Rust ↔ Mobile)](#2-ffi-interface-rust--mobile)
3. [Relay Server API](#3-relay-server-api)
4. [Data Schemas](#4-data-schemas)
5. [Error Codes](#5-error-codes)
6. [Authentication](#6-authentication)
7. [Rate Limiting](#7-rate-limiting)
8. [Versioning Strategy](#8-versioning-strategy)
9. [Code Examples](#9-code-examples)

---

## 1. Introduction

### 1.1 Purpose

This document defines all API contracts for Ya OK system components:
- **FFI Interface**: Rust core ↔ Android/iOS communication
- **Relay Server API**: UDP/TCP protocol for message relay
- **WebSocket Protocol**: Real-time communication (future)
- **Data Schemas**: Message formats, serialization

### 1.2 Scope

**APIs Covered:**
- Rust FFI (Foreign Function Interface) for Android (JNI) and iOS (Swift/C)
- Relay server UDP protocol (client ↔ server)
- HTTP health/metrics endpoints
- Internal data structures and serialization formats

**Out of Scope:**
- Third-party APIs (Firebase, Google Play Services)
- Platform-specific APIs (Android Bluetooth, iOS Keychain)
- Internal Rust module APIs (covered in code documentation)

### 1.3 API Design Principles

1. **Simplicity**: Clear, intuitive interfaces
2. **Consistency**: Uniform naming, patterns, error handling
3. **Backward Compatibility**: Versioned APIs, graceful degradation
4. **Security**: Authentication, encryption, input validation
5. **Performance**: Minimal overhead, efficient serialization
6. **Observability**: Structured logging, tracing support

### 1.4 API Stability Guarantees

| API Type | Stability | Breaking Changes |
|----------|-----------|------------------|
| **FFI Interface** | Stable | Major version only (v2.0.0) |
| **Relay Protocol** | Stable | Major version only |
| **Data Schemas** | Backward compatible | Additive changes allowed |
| **Error Codes** | Stable | New codes allowed, no removal |

---

## 2. FFI Interface (Rust ↔ Mobile)

### 2.1 Architecture Overview

```
┌───────────────────────────────────────────────────┐
│                Mobile App (Kotlin/Swift)          │
├───────────────────────────────────────────────────┤
│                      FFI Layer                     │
│  Android: JNI (Java Native Interface)             │
│  iOS: Swift/C Interop (cbindgen)                  │
├───────────────────────────────────────────────────┤
│              Rust Core (ya_ok_core)               │
│  Identity, Crypto, Messaging, Storage, Transport  │
└───────────────────────────────────────────────────┘
```

### 2.2 FFI Function Categories

| Category | Functions | Purpose |
|----------|-----------|---------|
| **Initialization** | `yaok_init`, `yaok_destroy` | Initialize/cleanup Rust core |
| **Identity** | `yaok_generate_identity`, `yaok_export_identity` | Key generation, QR export |
| **Contacts** | `yaok_add_contact`, `yaok_verify_contact` | Contact management |
| **Messaging** | `yaok_send_message`, `yaok_receive_message` | Message send/receive |
| **Crypto** | `yaok_encrypt`, `yaok_decrypt` | Encryption operations |
| **Storage** | `yaok_store_message`, `yaok_load_messages` | Database operations |
| **Transport** | `yaok_register_relay`, `yaok_ble_scan` | Network operations |

### 2.3 FFI Function Definitions

#### 2.3.1 Initialization

**yaok_init**

```c
// C Header (generated by cbindgen)
/**
 * Initialize the Ya OK core library.
 * 
 * @param db_path Path to SQLite database file
 * @param keystore_callback Callback to access platform keystore
 * @return YaokHandle* Opaque handle to core instance, NULL on error
 */
YaokHandle* yaok_init(
    const char* db_path,
    KeystoreCallback keystore_callback
);
```

**Android (Kotlin):**

```kotlin
// Android JNI Binding
external fun yaokInit(dbPath: String): Long

fun initializeYaOk(context: Context): YaOkCore {
    val dbPath = context.getDatabasePath("yaok.db").absolutePath
    val handle = yaokInit(dbPath)
    if (handle == 0L) {
        throw RuntimeException("Failed to initialize Ya OK core")
    }
    return YaOkCore(handle)
}
```

**iOS (Swift):**

```swift
// iOS Swift Binding
func yaokInit(dbPath: String) -> OpaquePointer? {
    return dbPath.withCString { path in
        yaok_init(path, keystoreCallback)
    }
}

func initializeYaOk() throws -> YaOkCore {
    let dbPath = FileManager.default
        .urls(for: .documentDirectory, in: .userDomainMask)[0]
        .appendingPathComponent("yaok.db")
        .path
    
    guard let handle = yaokInit(dbPath: dbPath) else {
        throw YaOkError.initializationFailed
    }
    
    return YaOkCore(handle: handle)
}
```

**yaok_destroy**

```c
/**
 * Cleanup and destroy Ya OK core instance.
 * 
 * @param handle Handle returned by yaok_init
 */
void yaok_destroy(YaokHandle* handle);
```

#### 2.3.2 Identity Management

**yaok_generate_identity**

```c
/**
 * Generate a new identity (keypairs).
 * 
 * @param handle Ya OK core handle
 * @param display_name User's display name (UTF-8, max 64 bytes)
 * @param out_identity Pointer to receive generated identity
 * @return YaokResult Result code (0 = success, error code otherwise)
 */
YaokResult yaok_generate_identity(
    YaokHandle* handle,
    const char* display_name,
    YaokIdentity** out_identity
);
```

**YaokIdentity Structure:**

```c
typedef struct {
    char user_id[37];              // UUID (36 chars + null terminator)
    char display_name[65];         // Display name (64 chars + null)
    uint8_t public_key_x25519[32]; // X25519 public key for encryption
    uint8_t public_key_ed25519[32];// Ed25519 public key for signing
    char fingerprint[129];         // BLAKE3 fingerprint (128 hex chars + null)
    uint64_t created_at;           // Unix timestamp (milliseconds)
} YaokIdentity;
```

**yaok_export_identity**

```c
/**
 * Export identity as QR code data.
 * 
 * @param handle Ya OK core handle
 * @param format Export format (0 = QR, 1 = JSON)
 * @param out_data Pointer to receive exported data (caller must free)
 * @param out_len Length of exported data
 * @return YaokResult Result code
 */
YaokResult yaok_export_identity(
    YaokHandle* handle,
    uint8_t format,
    uint8_t** out_data,
    size_t* out_len
);
```

**Export Format (QR Code URL):**

```
yaok://contact?v=1&d=<base64_encoded_data>

Decoded data structure:
{
  "version": 1,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "display_name": "Alice",
  "public_key_x25519": "base64...",
  "public_key_ed25519": "base64...",
  "signature": "base64..."  // Self-signed with Ed25519
}
```

#### 2.3.3 Contact Management

**yaok_add_contact**

```c
/**
 * Add a contact from scanned QR code data.
 * 
 * @param handle Ya OK core handle
 * @param qr_data QR code data (URL or JSON)
 * @param qr_len Length of QR data
 * @param out_contact Pointer to receive contact info
 * @return YaokResult Result code
 */
YaokResult yaok_add_contact(
    YaokHandle* handle,
    const uint8_t* qr_data,
    size_t qr_len,
    YaokContact** out_contact
);
```

**YaokContact Structure:**

```c
typedef struct {
    char user_id[37];
    char display_name[65];
    uint8_t public_key_x25519[32];
    uint8_t public_key_ed25519[32];
    char fingerprint[129];
    bool verified;                 // True if safety number verified
    uint64_t added_at;
    uint64_t last_seen;
} YaokContact;
```

**yaok_verify_contact**

```c
/**
 * Mark contact as verified after safety number check.
 * 
 * @param handle Ya OK core handle
 * @param user_id Contact's user ID
 * @return YaokResult Result code
 */
YaokResult yaok_verify_contact(
    YaokHandle* handle,
    const char* user_id
);
```

**yaok_get_safety_number**

```c
/**
 * Get safety number (fingerprint) for contact verification.
 * 
 * @param handle Ya OK core handle
 * @param user_id Contact's user ID
 * @param out_fingerprint Buffer to receive fingerprint (129 bytes)
 * @return YaokResult Result code
 */
YaokResult yaok_get_safety_number(
    YaokHandle* handle,
    const char* user_id,
    char* out_fingerprint
);
```

#### 2.3.4 Messaging

**yaok_send_message**

```c
/**
 * Send a message to a contact.
 * 
 * @param handle Ya OK core handle
 * @param recipient_id Recipient's user ID
 * @param content Message content (UTF-8 text or file data)
 * @param content_len Length of content
 * @param content_type Content type (0 = text, 1 = file)
 * @param out_message_id Pointer to receive message ID
 * @return YaokResult Result code
 */
YaokResult yaok_send_message(
    YaokHandle* handle,
    const char* recipient_id,
    const uint8_t* content,
    size_t content_len,
    uint8_t content_type,
    char* out_message_id  // 37 bytes (UUID + null)
);
```

**yaok_receive_message**

```c
/**
 * Process received message packet.
 * 
 * @param handle Ya OK core handle
 * @param packet Encrypted message packet
 * @param packet_len Length of packet
 * @param out_message Pointer to receive decrypted message
 * @return YaokResult Result code
 */
YaokResult yaok_receive_message(
    YaokHandle* handle,
    const uint8_t* packet,
    size_t packet_len,
    YaokMessage** out_message
);
```

**YaokMessage Structure:**

```c
typedef struct {
    char message_id[37];
    char sender_id[37];
    char recipient_id[37];
    uint8_t* content;
    size_t content_len;
    uint8_t content_type;         // 0 = text, 1 = file
    uint64_t timestamp;
    uint8_t status;               // 0 = sent, 1 = delivered, 2 = read
    uint8_t transport;            // 0 = BLE, 1 = WiFi, 2 = Relay
} YaokMessage;
```

**yaok_send_receipt**

```c
/**
 * Send delivery or read receipt.
 * 
 * @param handle Ya OK core handle
 * @param message_id Original message ID
 * @param receipt_type Receipt type (0 = delivered, 1 = read)
 * @return YaokResult Result code
 */
YaokResult yaok_send_receipt(
    YaokHandle* handle,
    const char* message_id,
    uint8_t receipt_type
);
```

#### 2.3.5 Transport Layer

**yaok_register_relay**

```c
/**
 * Register with relay server.
 * 
 * @param handle Ya OK core handle
 * @param relay_url Relay server URL (e.g., "relay.yaok.app:41641")
 * @return YaokResult Result code
 */
YaokResult yaok_register_relay(
    YaokHandle* handle,
    const char* relay_url
);
```

**yaok_unregister_relay**

```c
/**
 * Unregister from relay server.
 * 
 * @param handle Ya OK core handle
 * @return YaokResult Result code
 */
YaokResult yaok_unregister_relay(YaokHandle* handle);
```

**yaok_poll_relay**

```c
/**
 * Poll relay server for pending messages.
 * 
 * @param handle Ya OK core handle
 * @param out_messages Array to receive messages (caller must free)
 * @param out_count Number of messages received
 * @return YaokResult Result code
 */
YaokResult yaok_poll_relay(
    YaokHandle* handle,
    YaokMessage*** out_messages,
    size_t* out_count
);
```

### 2.4 Callback Functions

**KeystoreCallback** (Platform keystore access)

```c
/**
 * Callback to access platform keystore.
 * 
 * @param operation Operation type (0 = store, 1 = retrieve, 2 = delete)
 * @param key_id Key identifier
 * @param key_data Key data (input for store, output for retrieve)
 * @param key_len Length of key data
 * @param user_data User-provided context
 * @return int Result (0 = success, -1 = error)
 */
typedef int (*KeystoreCallback)(
    uint8_t operation,
    const char* key_id,
    uint8_t** key_data,
    size_t* key_len,
    void* user_data
);
```

**MessageReceivedCallback** (Async message notification)

```c
/**
 * Callback when message received (async).
 * 
 * @param message Received message
 * @param user_data User-provided context
 */
typedef void (*MessageReceivedCallback)(
    YaokMessage* message,
    void* user_data
);
```

**yaok_set_message_callback**

```c
/**
 * Register callback for incoming messages.
 * 
 * @param handle Ya OK core handle
 * @param callback Callback function
 * @param user_data User-provided context
 * @return YaokResult Result code
 */
YaokResult yaok_set_message_callback(
    YaokHandle* handle,
    MessageReceivedCallback callback,
    void* user_data
);
```

### 2.5 Memory Management

**Rules:**
1. **Strings**: All strings are UTF-8 null-terminated
2. **Buffers**: Caller responsible for allocated buffers (use `yaok_free`)
3. **Structures**: Freed with `yaok_free_*` functions
4. **Handles**: Must call `yaok_destroy` to cleanup

**yaok_free**

```c
/**
 * Free memory allocated by Rust.
 * 
 * @param ptr Pointer to free
 */
void yaok_free(void* ptr);
```

**yaok_free_identity**

```c
void yaok_free_identity(YaokIdentity* identity);
```

**yaok_free_contact**

```c
void yaok_free_contact(YaokContact* contact);
```

**yaok_free_message**

```c
void yaok_free_message(YaokMessage* message);
```

---

## 3. Relay Server API

### 3.1 Protocol Overview

**Transport:** UDP (primary), TCP (fallback, future)  
**Port:** 41641  
**Serialization:** Custom binary protocol (MessagePack-inspired)  
**Encryption:** End-to-end (relay cannot decrypt messages)

### 3.2 Packet Format

**All packets:**

```
┌─────────────────────────────────────────────────┐
│ Header (8 bytes)                                 │
├─────────────────────────────────────────────────┤
│ Version (1 byte) | Type (1 byte) | Reserved (2) │
│ Length (4 bytes) - Payload length                │
├─────────────────────────────────────────────────┤
│ Payload (variable length)                        │
│ ...                                              │
└─────────────────────────────────────────────────┘
```

**Header Fields:**
- **Version**: Protocol version (currently 0x01)
- **Type**: Packet type (see below)
- **Reserved**: Reserved for future use (0x0000)
- **Length**: Payload length in bytes (big-endian uint32)

### 3.3 Packet Types

| Type | Code | Direction | Description |
|------|------|-----------|-------------|
| **REGISTER** | 0x01 | Client → Server | Register with relay |
| **REGISTERED** | 0x02 | Server → Client | Registration success |
| **UNREGISTER** | 0x03 | Client → Server | Unregister from relay |
| **PING** | 0x04 | Client → Server | Heartbeat |
| **PONG** | 0x05 | Server → Client | Heartbeat response |
| **MESSAGE** | 0x10 | Client → Server | Send message |
| **MESSAGE_ACK** | 0x11 | Server → Client | Message acknowledged |
| **MESSAGE_DELIVER** | 0x12 | Server → Client | Deliver message |
| **POLL** | 0x20 | Client → Server | Poll for messages |
| **POLL_RESPONSE** | 0x21 | Server → Client | Poll response (messages) |
| **ERROR** | 0xFF | Server → Client | Error response |

### 3.4 Packet Payloads

#### REGISTER (0x01)

**Client → Server:**

```
┌─────────────────────────────────────────────────┐
│ User ID (36 bytes, UUID as ASCII)               │
├─────────────────────────────────────────────────┤
│ Public Key X25519 (32 bytes)                    │
├─────────────────────────────────────────────────┤
│ Public Key Ed25519 (32 bytes)                   │
├─────────────────────────────────────────────────┤
│ Signature (64 bytes) - Ed25519 signature        │
│   over (Version || Type || User ID || Keys)     │
└─────────────────────────────────────────────────┘

Total: 164 bytes
```

**Purpose:** Register user with relay server, providing public keys for routing.

#### REGISTERED (0x02)

**Server → Client:**

```
┌─────────────────────────────────────────────────┐
│ Session Token (16 bytes) - Random nonce         │
├─────────────────────────────────────────────────┤
│ Server Timestamp (8 bytes) - Unix millis        │
└─────────────────────────────────────────────────┘

Total: 24 bytes
```

**Purpose:** Confirm registration, provide session token.

#### PING (0x04)

**Client → Server:**

```
┌─────────────────────────────────────────────────┐
│ Session Token (16 bytes)                        │
└─────────────────────────────────────────────────┘

Total: 16 bytes
```

**Purpose:** Keep-alive heartbeat (sent every 60 seconds).

#### PONG (0x05)

**Server → Client:**

```
┌─────────────────────────────────────────────────┐
│ Server Timestamp (8 bytes)                      │
└─────────────────────────────────────────────────┘

Total: 8 bytes
```

#### MESSAGE (0x10)

**Client → Server:**

```
┌─────────────────────────────────────────────────┐
│ Session Token (16 bytes)                        │
├─────────────────────────────────────────────────┤
│ Message ID (36 bytes) - UUID                    │
├─────────────────────────────────────────────────┤
│ Recipient ID (36 bytes) - UUID                  │
├─────────────────────────────────────────────────┤
│ Encrypted Payload Length (4 bytes)              │
├─────────────────────────────────────────────────┤
│ Encrypted Payload (variable)                    │
│   - Encrypted with recipient's public key       │
│   - Format: Nonce (24) + Ciphertext + Tag (16)  │
└─────────────────────────────────────────────────┘

Total: 92 + payload length
```

**Purpose:** Send encrypted message to recipient via relay.

#### MESSAGE_ACK (0x11)

**Server → Client:**

```
┌─────────────────────────────────────────────────┐
│ Message ID (36 bytes)                           │
├─────────────────────────────────────────────────┤
│ Status (1 byte) - 0=queued, 1=delivered         │
└─────────────────────────────────────────────────┘

Total: 37 bytes
```

#### MESSAGE_DELIVER (0x12)

**Server → Client:**

```
┌─────────────────────────────────────────────────┐
│ Message ID (36 bytes)                           │
├─────────────────────────────────────────────────┤
│ Sender ID (36 bytes)                            │
├─────────────────────────────────────────────────┤
│ Timestamp (8 bytes) - Server received time      │
├─────────────────────────────────────────────────┤
│ Encrypted Payload Length (4 bytes)              │
├─────────────────────────────────────────────────┤
│ Encrypted Payload (variable)                    │
└─────────────────────────────────────────────────┘

Total: 84 + payload length
```

#### POLL (0x20)

**Client → Server:**

```
┌─────────────────────────────────────────────────┐
│ Session Token (16 bytes)                        │
├─────────────────────────────────────────────────┤
│ Last Message ID (36 bytes) - Optional, 0s if    │
│   first poll, UUID of last received message     │
└─────────────────────────────────────────────────┘

Total: 52 bytes
```

**Purpose:** Request pending messages from relay queue.

#### POLL_RESPONSE (0x21)

**Server → Client:**

```
┌─────────────────────────────────────────────────┐
│ Message Count (2 bytes) - Number of messages    │
├─────────────────────────────────────────────────┤
│ Messages (variable)                              │
│   For each message:                              │
│     - Message ID (36 bytes)                      │
│     - Sender ID (36 bytes)                       │
│     - Timestamp (8 bytes)                        │
│     - Payload Length (4 bytes)                   │
│     - Encrypted Payload (variable)               │
└─────────────────────────────────────────────────┘

Total: 2 + (84 + payload) * count
```

#### ERROR (0xFF)

**Server → Client:**

```
┌─────────────────────────────────────────────────┐
│ Error Code (2 bytes) - See error codes below    │
├─────────────────────────────────────────────────┤
│ Error Message Length (1 byte)                   │
├─────────────────────────────────────────────────┤
│ Error Message (variable, UTF-8)                 │
└─────────────────────────────────────────────────┘

Total: 3 + message length
```

### 3.5 HTTP Endpoints

**Health Check:**

```
GET /health

Response 200 OK:
{
  "status": "healthy",
  "version": "0.2.0",
  "uptime_seconds": 86400,
  "active_connections": 1234
}
```

**Metrics (Prometheus):**

```
GET /metrics

Response 200 OK:
# HELP relay_requests_total Total requests received
# TYPE relay_requests_total counter
relay_requests_total{type="register"} 1500
relay_requests_total{type="message"} 45000
...
```

**Version Info:**

```
GET /version

Response 200 OK:
{
  "version": "0.2.0",
  "protocol_version": 1,
  "build_date": "2026-02-06T10:00:00Z",
  "commit": "abc123def"
}
```

### 3.6 Rate Limiting

| Operation | Limit | Window | Action on Exceed |
|-----------|-------|--------|------------------|
| **Register** | 10 per IP | 10 minutes | Reject with 429 |
| **Message Send** | 100 per user | 1 minute | Queue or reject |
| **Poll** | 60 per user | 1 minute | Reject with 429 |
| **Ping** | 2 per user | 1 minute | Drop silently |

**Rate Limit Error:**

```
ERROR packet (0xFF)
Error Code: 0x0429 (Too Many Requests)
Error Message: "Rate limit exceeded. Retry after 45 seconds."
```

---

## 4. Data Schemas

### 4.1 Message Schema

**Encrypted Message Packet:**

```
┌─────────────────────────────────────────────────┐
│ Nonce (24 bytes) - XChaCha20-Poly1305 nonce     │
├─────────────────────────────────────────────────┤
│ Ciphertext (variable)                            │
│   Encrypted plaintext message (see below)       │
├─────────────────────────────────────────────────┤
│ Authentication Tag (16 bytes) - AEAD tag        │
└─────────────────────────────────────────────────┘

Total: 40 + ciphertext length
```

**Plaintext Message (before encryption):**

```json
{
  "version": 1,
  "message_id": "550e8400-e29b-41d4-a716-446655440000",
  "sender_id": "660e8400-e29b-41d4-a716-446655440001",
  "recipient_id": "770e8400-e29b-41d4-a716-446655440002",
  "timestamp": 1709726400000,
  "content_type": "text",
  "content": "Hello, World!",
  "signature": "base64_encoded_ed25519_signature"
}
```

**Fields:**
- **version**: Protocol version (1)
- **message_id**: UUID v4
- **sender_id**: Sender's user ID
- **recipient_id**: Recipient's user ID
- **timestamp**: Unix timestamp (milliseconds)
- **content_type**: `"text"` | `"file"` | `"receipt"`
- **content**: Message content (text, base64 file, or receipt data)
- **signature**: Ed25519 signature over all fields

**File Message:**

```json
{
  "version": 1,
  "message_id": "...",
  "sender_id": "...",
  "recipient_id": "...",
  "timestamp": 1709726400000,
  "content_type": "file",
  "content": {
    "file_name": "photo.jpg",
    "file_size": 1048576,
    "mime_type": "image/jpeg",
    "file_hash": "sha256_hex",
    "file_data": "base64_encoded_file_data"
  },
  "signature": "..."
}
```

**Receipt Message:**

```json
{
  "version": 1,
  "message_id": "...",
  "sender_id": "...",
  "recipient_id": "...",
  "timestamp": 1709726400000,
  "content_type": "receipt",
  "content": {
    "original_message_id": "550e8400-...",
    "receipt_type": "delivered",  // "delivered" | "read"
    "timestamp": 1709726450000
  },
  "signature": "..."
}
```

### 4.2 Database Schema

**SQLite Tables:**

**users:**

```sql
CREATE TABLE users (
    user_id TEXT PRIMARY KEY,
    display_name TEXT NOT NULL,
    public_key_x25519 BLOB NOT NULL,
    public_key_ed25519 BLOB NOT NULL,
    fingerprint TEXT NOT NULL,
    created_at INTEGER NOT NULL
);
```

**contacts:**

```sql
CREATE TABLE contacts (
    user_id TEXT PRIMARY KEY,
    display_name TEXT NOT NULL,
    public_key_x25519 BLOB NOT NULL,
    public_key_ed25519 BLOB NOT NULL,
    fingerprint TEXT NOT NULL,
    verified INTEGER NOT NULL DEFAULT 0,
    added_at INTEGER NOT NULL,
    last_seen INTEGER
);
```

**messages:**

```sql
CREATE TABLE messages (
    message_id TEXT PRIMARY KEY,
    sender_id TEXT NOT NULL,
    recipient_id TEXT NOT NULL,
    content_type TEXT NOT NULL,
    content BLOB NOT NULL,
    timestamp INTEGER NOT NULL,
    status INTEGER NOT NULL,  -- 0=sent, 1=delivered, 2=read
    transport INTEGER NOT NULL,  -- 0=BLE, 1=WiFi, 2=Relay
    created_at INTEGER NOT NULL,
    FOREIGN KEY (sender_id) REFERENCES contacts(user_id),
    FOREIGN KEY (recipient_id) REFERENCES contacts(user_id)
);

CREATE INDEX idx_messages_recipient ON messages(recipient_id, timestamp);
CREATE INDEX idx_messages_sender ON messages(sender_id, timestamp);
```

**routing_table:**

```sql
CREATE TABLE routing_table (
    user_id TEXT PRIMARY KEY,
    transport TEXT NOT NULL,  -- 'ble' | 'wifi' | 'relay'
    address TEXT NOT NULL,    -- BLE MAC, WiFi IP, Relay session
    last_seen INTEGER NOT NULL,
    FOREIGN KEY (user_id) REFERENCES contacts(user_id)
);
```

### 4.3 Serialization Format

**Binary Serialization (Custom):**

Used for internal storage and network transmission (smaller than JSON).

**Format:**

```
Field lengths:
- UUID: 16 bytes (binary)
- Timestamp: 8 bytes (uint64, big-endian)
- String: 2 bytes length + UTF-8 bytes
- Blob: 4 bytes length + binary data
```

**Example (Text Message):**

```
Byte offset | Field               | Length
------------|---------------------|--------
0-15        | Message ID          | 16
16-31       | Sender ID           | 16
32-47       | Recipient ID        | 16
48-55       | Timestamp           | 8
56          | Content Type        | 1 (0x00 = text)
57-58       | Content Length      | 2 (big-endian)
59-...      | Content             | variable
...         | Signature           | 64
```

---

## 5. Error Codes

### 5.1 FFI Error Codes

| Code | Name | Description |
|------|------|-------------|
| **0** | `YAOK_OK` | Success |
| **1** | `YAOK_ERROR_INIT_FAILED` | Initialization failed |
| **2** | `YAOK_ERROR_INVALID_PARAM` | Invalid parameter |
| **3** | `YAOK_ERROR_KEYSTORE_ACCESS` | Keystore access denied |
| **4** | `YAOK_ERROR_CRYPTO_FAILED` | Cryptographic operation failed |
| **5** | `YAOK_ERROR_DATABASE_FAILED` | Database operation failed |
| **6** | `YAOK_ERROR_NETWORK_FAILED` | Network operation failed |
| **7** | `YAOK_ERROR_NOT_FOUND` | Resource not found |
| **8** | `YAOK_ERROR_ALREADY_EXISTS` | Resource already exists |
| **9** | `YAOK_ERROR_INVALID_SIGNATURE` | Signature verification failed |
| **10** | `YAOK_ERROR_DECRYPTION_FAILED` | Decryption failed |
| **11** | `YAOK_ERROR_TIMEOUT` | Operation timed out |
| **12** | `YAOK_ERROR_PERMISSION_DENIED` | Permission denied |

**C Enum:**

```c
typedef enum {
    YAOK_OK = 0,
    YAOK_ERROR_INIT_FAILED = 1,
    YAOK_ERROR_INVALID_PARAM = 2,
    YAOK_ERROR_KEYSTORE_ACCESS = 3,
    YAOK_ERROR_CRYPTO_FAILED = 4,
    YAOK_ERROR_DATABASE_FAILED = 5,
    YAOK_ERROR_NETWORK_FAILED = 6,
    YAOK_ERROR_NOT_FOUND = 7,
    YAOK_ERROR_ALREADY_EXISTS = 8,
    YAOK_ERROR_INVALID_SIGNATURE = 9,
    YAOK_ERROR_DECRYPTION_FAILED = 10,
    YAOK_ERROR_TIMEOUT = 11,
    YAOK_ERROR_PERMISSION_DENIED = 12,
} YaokResult;
```

### 5.2 Relay Server Error Codes

| Code | Hex | Description |
|------|-----|-------------|
| **1000** | 0x03E8 | Invalid packet format |
| **1001** | 0x03E9 | Invalid protocol version |
| **1002** | 0x03EA | Invalid signature |
| **1003** | 0x03EB | User not registered |
| **1004** | 0x03EC | Session expired |
| **1005** | 0x03ED | Recipient not found |
| **1006** | 0x03EE | Message too large |
| **1007** | 0x03EF | Queue full |
| **1100** | 0x044C | Rate limit exceeded (429) |
| **1500** | 0x05DC | Internal server error (500) |

---

## 6. Authentication

### 6.1 Client Authentication

**Method:** Ed25519 Digital Signatures

**Flow:**
1. Client registers with relay server
2. Sends public key (Ed25519) in REGISTER packet
3. Signs registration packet with private key
4. Server verifies signature
5. Server issues session token
6. Client includes session token in subsequent requests

### 6.2 Message Authentication

**Every message includes:**
- Sender's Ed25519 signature
- Timestamp (prevents replay attacks)
- Nonce (prevents message duplication)

**Verification:**
1. Recipient extracts sender's public key from contacts
2. Verifies Ed25519 signature
3. Checks timestamp (reject if >5 minutes old or in future)
4. Checks nonce uniqueness (reject duplicates)

---

## 7. Rate Limiting

### 7.1 Client-Side Rate Limiting

**Purpose:** Prevent abuse, ensure fair usage

**Limits:**

| Operation | Limit | Window | Implementation |
|-----------|-------|--------|----------------|
| Message Send | 100 | 1 minute | Token bucket (local) |
| Contact Add | 50 | 1 hour | Token bucket (local) |
| Relay Poll | 60 | 1 minute | Fixed window (local) |

### 7.2 Server-Side Rate Limiting

**Per-IP Limits:**

```rust
// Token bucket algorithm
struct RateLimiter {
    capacity: u32,      // Max tokens (100)
    refill_rate: f64,   // Tokens per second (100/60 = 1.67)
    tokens: f64,        // Current tokens
    last_refill: Instant,
}

impl RateLimiter {
    fn allow(&mut self) -> bool {
        self.refill();
        if self.tokens >= 1.0 {
            self.tokens -= 1.0;
            true
        } else {
            false
        }
    }
    
    fn refill(&mut self) {
        let now = Instant::now();
        let elapsed = now.duration_since(self.last_refill).as_secs_f64();
        self.tokens = (self.tokens + elapsed * self.refill_rate).min(self.capacity as f64);
        self.last_refill = now;
    }
}
```

---

## 8. Versioning Strategy

### 8.1 API Version Format

**Semantic Versioning:** MAJOR.MINOR.PATCH

- **MAJOR**: Breaking changes (e.g., 1.0.0 → 2.0.0)
- **MINOR**: Backward-compatible features (e.g., 1.0.0 → 1.1.0)
- **PATCH**: Bug fixes (e.g., 1.0.0 → 1.0.1)

### 8.2 Protocol Versioning

**Current Protocol Version:** 1

**Version Negotiation:**
- All packets include protocol version in header
- Server rejects packets with unsupported versions
- Client can support multiple versions (fallback)

**Example:**

```
Client sends: Version 2 (future)
Server responds: ERROR (0xFF) - "Unsupported protocol version. Server supports: 1"
Client retries: Version 1
Server responds: SUCCESS
```

### 8.3 Backward Compatibility

**Rules:**
1. **No removal of fields** (mark as deprecated instead)
2. **Additive changes only** for minor versions
3. **New optional fields** must have defaults
4. **Version negotiation** for major changes

**Example (Backward Compatible):**

```json
// Version 1.0
{
  "message_id": "...",
  "content": "Hello"
}

// Version 1.1 (adds optional field)
{
  "message_id": "...",
  "content": "Hello",
  "priority": "normal"  // NEW: optional, default = "normal"
}
```

---

## 9. Code Examples

### 9.1 Android Integration

**Initialize Ya OK:**

```kotlin
class YaOkRepository(private val context: Context) {
    private var coreHandle: Long = 0
    
    fun initialize() {
        val dbPath = context.getDatabasePath("yaok.db").absolutePath
        coreHandle = yaokInit(dbPath)
        if (coreHandle == 0L) {
            throw RuntimeException("Failed to initialize Ya OK core")
        }
        
        // Set message callback
        yaokSetMessageCallback(coreHandle, ::onMessageReceived)
    }
    
    private fun onMessageReceived(message: YaokMessage) {
        // Handle incoming message
        _messages.postValue(message)
    }
    
    fun cleanup() {
        if (coreHandle != 0L) {
            yaokDestroy(coreHandle)
            coreHandle = 0
        }
    }
    
    // JNI Functions
    private external fun yaokInit(dbPath: String): Long
    private external fun yaokDestroy(handle: Long)
    private external fun yaokSetMessageCallback(handle: Long, callback: (YaokMessage) -> Unit)
    
    companion object {
        init {
            System.loadLibrary("yaok_core")
        }
    }
}
```

**Send Message:**

```kotlin
suspend fun sendMessage(recipientId: String, content: String): String {
    return withContext(Dispatchers.IO) {
        val messageId = yaokSendMessage(
            coreHandle,
            recipientId,
            content.toByteArray(Charsets.UTF_8),
            0  // content_type: text
        )
        if (messageId.isEmpty()) {
            throw RuntimeException("Failed to send message")
        }
        messageId
    }
}

private external fun yaokSendMessage(
    handle: Long,
    recipientId: String,
    content: ByteArray,
    contentType: Int
): String
```

### 9.2 iOS Integration

**Initialize Ya OK:**

```swift
class YaOkManager {
    private var coreHandle: OpaquePointer?
    
    func initialize() throws {
        let dbPath = FileManager.default
            .urls(for: .documentDirectory, in: .userDomainMask)[0]
            .appendingPathComponent("yaok.db")
            .path
        
        coreHandle = dbPath.withCString { path in
            yaok_init(path, keystoreCallback)
        }
        
        guard coreHandle != nil else {
            throw YaOkError.initializationFailed
        }
        
        // Set message callback
        yaok_set_message_callback(coreHandle, messageReceivedCallback, nil)
    }
    
    func cleanup() {
        if let handle = coreHandle {
            yaok_destroy(handle)
            coreHandle = nil
        }
    }
    
    private let messageReceivedCallback: MessageReceivedCallback = { message, userData in
        guard let message = message else { return }
        // Handle incoming message
        NotificationCenter.default.post(
            name: .yaokMessageReceived,
            object: message.pointee
        )
    }
}
```

**Send Message:**

```swift
func sendMessage(recipientId: String, content: String) throws -> String {
    guard let handle = coreHandle else {
        throw YaOkError.notInitialized
    }
    
    var messageId = [CChar](repeating: 0, count: 37)
    let contentData = content.data(using: .utf8)!
    
    let result = contentData.withUnsafeBytes { contentPtr in
        yaok_send_message(
            handle,
            recipientId,
            contentPtr.baseAddress?.assumingMemoryBound(to: UInt8.self),
            contentData.count,
            0,  // content_type: text
            &messageId
        )
    }
    
    guard result == YAOK_OK else {
        throw YaOkError.sendFailed(code: result)
    }
    
    return String(cString: messageId)
}
```

### 9.3 Relay Server Client

**Rust Client Example:**

```rust
use tokio::net::UdpSocket;

struct RelayClient {
    socket: UdpSocket,
    session_token: Option<[u8; 16]>,
}

impl RelayClient {
    async fn register(&mut self, user_id: &str, keys: &KeyPair) -> Result<()> {
        // Build REGISTER packet
        let mut packet = Vec::new();
        packet.push(0x01);  // Version
        packet.push(0x01);  // Type: REGISTER
        packet.extend_from_slice(&[0x00, 0x00]);  // Reserved
        
        let payload = build_register_payload(user_id, keys)?;
        packet.extend_from_slice(&(payload.len() as u32).to_be_bytes());
        packet.extend_from_slice(&payload);
        
        // Send packet
        self.socket.send(&packet).await?;
        
        // Receive REGISTERED response
        let mut buf = [0u8; 1024];
        let len = self.socket.recv(&mut buf).await?;
        
        if buf[1] == 0x02 {  // REGISTERED
            self.session_token = Some(buf[8..24].try_into()?);
            Ok(())
        } else if buf[1] == 0xFF {  // ERROR
            Err(parse_error(&buf[8..len]))
        } else {
            Err(anyhow!("Unexpected response"))
        }
    }
    
    async fn send_message(&self, recipient: &str, payload: &[u8]) -> Result<String> {
        let message_id = Uuid::new_v4().to_string();
        
        // Build MESSAGE packet
        let mut packet = Vec::new();
        packet.push(0x01);  // Version
        packet.push(0x10);  // Type: MESSAGE
        packet.extend_from_slice(&[0x00, 0x00]);
        
        let mut msg_payload = Vec::new();
        msg_payload.extend_from_slice(self.session_token.as_ref().unwrap());
        msg_payload.extend_from_slice(message_id.as_bytes());
        msg_payload.extend_from_slice(recipient.as_bytes());
        msg_payload.extend_from_slice(&(payload.len() as u32).to_be_bytes());
        msg_payload.extend_from_slice(payload);
        
        packet.extend_from_slice(&(msg_payload.len() as u32).to_be_bytes());
        packet.extend_from_slice(&msg_payload);
        
        self.socket.send(&packet).await?;
        
        // Wait for ACK
        let mut buf = [0u8; 1024];
        let len = self.socket.recv(&mut buf).await?;
        
        if buf[1] == 0x11 {  // MESSAGE_ACK
            Ok(message_id)
        } else {
            Err(anyhow!("Message send failed"))
        }
    }
}
```

---

## Appendix A: FFI Header (cbindgen output)

**yaok_core.h** (excerpt):

```c
#ifndef YAOK_CORE_H
#define YAOK_CORE_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

// Opaque handle to Ya OK core instance
typedef struct YaokHandle YaokHandle;

// Result codes
typedef enum {
    YAOK_OK = 0,
    YAOK_ERROR_INIT_FAILED = 1,
    YAOK_ERROR_INVALID_PARAM = 2,
    // ... (see section 5.1)
} YaokResult;

// Identity structure
typedef struct {
    char user_id[37];
    char display_name[65];
    uint8_t public_key_x25519[32];
    uint8_t public_key_ed25519[32];
    char fingerprint[129];
    uint64_t created_at;
} YaokIdentity;

// Contact structure
typedef struct {
    char user_id[37];
    char display_name[65];
    uint8_t public_key_x25519[32];
    uint8_t public_key_ed25519[32];
    char fingerprint[129];
    bool verified;
    uint64_t added_at;
    uint64_t last_seen;
} YaokContact;

// Message structure
typedef struct {
    char message_id[37];
    char sender_id[37];
    char recipient_id[37];
    uint8_t* content;
    size_t content_len;
    uint8_t content_type;
    uint64_t timestamp;
    uint8_t status;
    uint8_t transport;
} YaokMessage;

// Callback types
typedef int (*KeystoreCallback)(uint8_t operation, const char* key_id, 
                                 uint8_t** key_data, size_t* key_len, void* user_data);
typedef void (*MessageReceivedCallback)(YaokMessage* message, void* user_data);

// Core functions
YaokHandle* yaok_init(const char* db_path, KeystoreCallback keystore_callback);
void yaok_destroy(YaokHandle* handle);

// Identity functions
YaokResult yaok_generate_identity(YaokHandle* handle, const char* display_name, 
                                   YaokIdentity** out_identity);
YaokResult yaok_export_identity(YaokHandle* handle, uint8_t format, 
                                uint8_t** out_data, size_t* out_len);

// Contact functions
YaokResult yaok_add_contact(YaokHandle* handle, const uint8_t* qr_data, 
                            size_t qr_len, YaokContact** out_contact);
YaokResult yaok_verify_contact(YaokHandle* handle, const char* user_id);
YaokResult yaok_get_safety_number(YaokHandle* handle, const char* user_id, 
                                  char* out_fingerprint);

// Messaging functions
YaokResult yaok_send_message(YaokHandle* handle, const char* recipient_id, 
                             const uint8_t* content, size_t content_len, 
                             uint8_t content_type, char* out_message_id);
YaokResult yaok_receive_message(YaokHandle* handle, const uint8_t* packet, 
                                size_t packet_len, YaokMessage** out_message);
YaokResult yaok_send_receipt(YaokHandle* handle, const char* message_id, 
                             uint8_t receipt_type);
YaokResult yaok_set_message_callback(YaokHandle* handle, 
                                     MessageReceivedCallback callback, void* user_data);

// Transport functions
YaokResult yaok_register_relay(YaokHandle* handle, const char* relay_url);
YaokResult yaok_unregister_relay(YaokHandle* handle);
YaokResult yaok_poll_relay(YaokHandle* handle, YaokMessage*** out_messages, 
                           size_t* out_count);

// Memory management
void yaok_free(void* ptr);
void yaok_free_identity(YaokIdentity* identity);
void yaok_free_contact(YaokContact* contact);
void yaok_free_message(YaokMessage* message);

#ifdef __cplusplus
}
#endif

#endif // YAOK_CORE_H
```

---

## Appendix B: API Change Log

| Version | Date | Changes |
|---------|------|---------|
| **1.0.0** | 2026-02-06 | Initial API release |
| | | - FFI interface for Android/iOS |
| | | - Relay server UDP protocol |
| | | - Message schemas |

---

**Document Classification:** INTERNAL  
**Distribution:** Engineering Team, QA Team  
**Review Cycle:** Updated on API changes

**End of API Contracts Document**
